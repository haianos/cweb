---
layout: page
title: "My first cblock example in C ( with autogenerated toolchain! )"
---

## Contents
{:.no_toc}

* toc here
{:toc}

Goals
-------------
The tutorial shows how to implement a cblock written in C with the support of an autogenerated tool. The advantage of this approach is to produce faster, error-prone cblock implementations.
The workflow consists on:

  1. Define a package model, that is a bundle which will contain your software
  2. Define the model of the cblocks you would like to implement
  3. Generate all the sources skeleton and setup the environment to compile the sources
  4. Complete the step function of the cblocks in the source
  5. Compile and run it!

Thanks for the "modeling first" approach, it is possible to verify beforehand generation the correctness of the model.

Before to start, you should have in mind what you would like to generate.
In this tutorial, the goal is to generate a basic application composed by two cblock: a _sender_ and a _receiver_ , thus you want to generate a package which contains:

* _sender_ and _receiver_ implementation
* a custom datatype exchanged between the two cblocks
* compile the modules (three in total: one for the new datatype, and two for the blocks)
* write a .usc file to run the application

This tutorial fully apply to cblocks written in C++.

Prerequisites
-------------

To run and understand this tutorial, be sure that:

* you already [installed Microblx](/quickstart/)
* you already [installed microblx_cmake)() tool
* you read the [documentation]() (or you would like to have it close to you)
* (very) basic knowledge about [CMake framework](http://www.cmake.org/)

Model Design: how to generate a package
--------------------

### The package model

The first step is to create a package model (extension .pkg) which describes the future contents of your package. Using your favorite text editor, you create a new file named _cblock_tutorial_auto.pkg_ with the following informations
{% highlight lua %}
return pkg
{
  name="cblock_tutorial_auto",
  path="../",
  
  types = {
    { name="my_data", dir="types" },
  },
  
  blocks = {
    { name="sender", file="sender_block.blx", src_dir="src" },
    { name="receiver", file="receiver_block.blx", src_dir="src" },
  },
  
  modules = {
    { name="sendermod", blocks={"sender"} },
    { name="receivermod", blocks={"receiver"} },
  },
}
{% endhighlight %}

In short, in this description you are saying that the package name is _cblock_tutorial_auto_ and it will contains:

+ a new datatype definition, called _cpp_data_ (sources stored in the folder _types_ of your package)
+ two new blocks sources, stored in the foulder _src_ . The skeleton of the blocks is indicated in the block models (you have to create those!)
+ once the sources have been compiled, you will obtain two modules for each block.

> Please, notice that the latest is a pure design decision: you could prefer to have your blocks in one single module.
{% highlight lua %}
  modules = {
    { name="cblock_tutorial", blocks={"sender","receiver"} },
  },
}
{% endhighlight %}

> Note: a module name must not have the same name of a block

Further details about the package model can be found in the [Documentation]().

### The block model

{% highlight lua %}
return block
{
      name="sender",
      meta_data="A sender cblock which can handle my data",
      port_cache=true,

      types = {
        -- define types this blocks uses
	 { name="my_data", class='struct' },
      },

      ports = {
	-- define the ports for this block
	 { name="output", out_type_name="struct my_data", out_data_len=1, doc="output port for my data" },
      },
      
      -- define which operations this block implements
      operations = { start=true, stop=true, step=true },

      cpp = false,
}
{% endhighlight %}

{% highlight lua %}
return block
{
      name="receiver",
      meta_data="A receiver cblock which can handle my data",
      port_cache=true,

      types = {
	-- define types this blocks uses
	 { name="my_data", class='struct' },
      },

      ports = {
	-- define the ports for this block
	 { name="input", in_type_name="struct my_data", in_data_len=1, doc="input port for my data" },
      },
      
      -- define which operations this block implements
      operations = { start=true, stop=true, step=true },

      cpp = false,
}
{% endhighlight %}

> The flag "cpp = false" is used to generate .c and .h files instead of .cpp and .hpp files. Apart of that, the rest of the tutorial applies to C++ cblocks too.

> The "types" field assumes a different meaning in this context. While in the package model is the new datatype you want to define, in the block model is the list of datatypes the block is going to use.

### Generate the package!

{% highlight lua %}
~/workspace/microblx_cmake$ ubx_pkg_gen -s cblock_tutorial_auto.pkg -d ../cblock_tutorial_auto
/home/haianos/enea_microblx/testinstall/share/ubx/metamodels/
    generating ../cblock_tutorial_auto/src/sender.h
    generating ../cblock_tutorial_auto/src/sender.c
    generating ../cblock_tutorial_auto/src/sender.usc
    generating ../cblock_tutorial_auto/src/receiver.h
    generating ../cblock_tutorial_auto/src/receiver.c
    generating ../cblock_tutorial_auto/src/receiver.usc
    generating ../cblock_tutorial_auto/modules/sendermod_module.h
    generating ../cblock_tutorial_auto/modules/sendermod_module.c
    generating ../cblock_tutorial_auto/modules/receivermod_module.h
    generating ../cblock_tutorial_auto/modules/receivermod_module.c
    export models in ../cblock_tutorial_auto/models
{% endhighlight %}

Implement ubx types and blocks
------------------------------

In this step you have to fill in the generated stubs for your types and blocks.


### Implement the types

First, have a look at the types directory and the generated header files (one for each type you defined).
In our example, two files have been generated:

{% highlight lua %}
~/workspace/microblx_cmake$ cd ../cpp_transfer/types/
jphilips@CIB-11-009:~/workspace/cpp_transfer/types$ ls
cpp_data.h  cpp_transfer_types.c
{% endhighlight %}

The cpp_data.h file defines the model implementation of the type you want to share between ubx blocks, while the cpp_transfer_types.c file defines ubx functions to register all the types in this directory. The former still requires some editing, while the latter should be fine in most cases.

{% highlight lua %}
~/workspace/cpp_transfer/types$ vim cpp_data.h 
/* generated type stub, extend this struct with real information */

struct cpp_data {
	/* This should be generated in the future */
        const char model[20]; // This should be a URL to the data model
	const char uid[10]; // This should be a unique id to identify this data type
	const char meta_model[20]; // This should be a URL to the meta model
	const char data[10]; // the actually data. In our example, just 10 random characters.
};
{% endhighlight %}

### Implement the blocks

In this very basic example, we will only edit the step function of the sender and receiver block and set the license at the top

{% highlight lua %}
UBX_MODULE_LICENSE_SPDX(GPL-2.0+)

...

/* step */
void sender_step(ubx_block_t *b)
{
  struct sender_info *inf = (struct sender_info*) b->private_data;
  struct my_data data;
  strcpy(data.model, "image array");
  strcpy(data.uid,"image");
  strcpy(data.meta_model,"c array");
  strcpy(data.data,"test_data");

  write_output(inf->ports.output, &data);
}
{% endhighlight %}

In the receiver block we also include iostream

{% highlight lua %}
#include <iostream>
using namespace std;

UBX_MODULE_LICENSE_SPDX(GPL-2.0+)

...

/* step */
void receiver_step(ubx_block_t *b)
{
  struct receiver_info *inf = (struct receiver_info*) b->private_data;
  struct my_data dat;
  read_input(inf->ports.input, &dat);
  printf("MODEL: %s\n",dat.model);
  printf("UID: %s\n",dat.uid);
  printf("META MODEL: %s\n", dat.meta_model);
  printf("DATA: %s\n",  dat.data);
}
{% endhighlight %}

Note: At the moment, there is still a problem with type registration and to avoid runtime errors remove in either cpp_sender.hpp or cpp_receiver.hpp the type definition:

From:

{% highlight lua %}
ubx_type_t types[] = {
        def_struct_type(struct cpp_data, &cpp_data_h),
        { NULL },
};
{% endhighlight %}

To:

{% highlight lua %}
ubx_type_t types[] = {};
{% endhighlight %}

### Build with CMAKE

Note: In ccmake, set the install path of your package libraries. E.g. ~/workspace/install

{% highlight bash %}
~/workspace/cpp_transfer$ mkdir build && cd build/
~/workspace/cpp_transfer/build$ cmake ../
~/workspace/cpp_transfer/build$ ccmake ../
~/workspace/cpp_transfer/build$ make
[ 25%] Built target gen_hexarr
[ 50%] Building CXX object CMakeFiles/cpp_receiver.dir/src/cpp_receiver.cpp.o
Linking CXX shared library cpp_receiver.so
[ 50%] Built target cpp_receiver
[ 75%] Building CXX object CMakeFiles/cpp_sender.dir/src/cpp_sender.cpp.o
Linking CXX shared library cpp_sender.so
[ 75%] Built target cpp_sender
Scanning dependencies of target cpp_transfer_types
[100%] Building C object CMakeFiles/cpp_transfer_types.dir/types/cpp_transfer_types.c.o
Linking C shared library cpp_transfer_types.so
[100%] Built target cpp_transfer_types
~/workspace/cpp_transfer/build$ make install
[ 25%] Built target gen_hexarr
[ 50%] Built target cpp_receiver
[ 75%] Built target cpp_sender
[100%] Built target cpp_transfer_types
Install the project...
-- Install configuration: ""
-- Installing: /home/jphilips/workspace/install/lib/microblx/types/cpp_transfer_types.so
-- Set runtime path of "/home/jphilips/workspace/install/lib/microblx/types/cpp_transfer_types.so" to "/home/jphilips/workspace/microblx/src"
-- Installing: /home/jphilips/workspace/install/include/microblx/types/cpp_data.h.hexarr
-- Installing: /home/jphilips/workspace/install/include/microblx/types/cpp_data.h
-- Installing: /home/jphilips/workspace/install/lib/microblx/blocks/cpp_sender.so
-- Set runtime path of "/home/jphilips/workspace/install/lib/microblx/blocks/cpp_sender.so" to "/home/jphilips/workspace/microblx/src"
-- Installing: /home/jphilips/workspace/install/share/microblx/cmake/cpp_sender-block.cmake
-- Installing: /home/jphilips/workspace/install/share/microblx/cmake/cpp_sender-block-noconfig.cmake
-- Installing: /home/jphilips/workspace/install/lib/microblx/blocks/cpp_receiver.so
-- Set runtime path of "/home/jphilips/workspace/install/lib/microblx/blocks/cpp_receiver.so" to "/home/jphilips/workspace/microblx/src"
-- Installing: /home/jphilips/workspace/install/share/microblx/cmake/cpp_receiver-block.cmake
-- Installing: /home/jphilips/workspace/install/share/microblx/cmake/cpp_receiver-block-noconfig.cmake
{% endhighlight %}

Running the example
-------------------

### Create USC script

To deploy our application, procede on creating a Ubx System Composition file (USC) named _cblock_tutorial_auto.usc_
For our tutorial, we need to fill in the following informations.
{% highlight lua %}
return bd.system {
   imports = {
      "std_types/stdtypes/stdtypes.so",
      "std_blocks/ptrig/ptrig.so",
      "std_blocks/lfds_buffers/lfds_cyclic.so",
      "std_blocks/hexdump/hexdump.so",
      "types/cblock_tutorial_auto_types.so",
      "blocks/sendermod.so",
      "blocks/receivermod.so",
   },
   
   blocks = {
      {name="ptrig1", type="std_triggers/ptrig"},
      {name="fifo1", type="lfds_buffers/cyclic"},
      {name="sender1", type="sender"},
      {name="receiver1", type="receiver"},
   },
   
   connections = {
-- connect the sender block with the receiver block through a fifo block
      {src="sender1.output", tgt="fifo1"},
      {src="fifo1", tgt="receiver1.input"},
   },
   
   configurations = {
      { name="fifo1", config={type_name="struct my_data", buffer_len=1} },
      { name="ptrig1", config={ period={sec=1,usec=0}, 
                                trig_blocks={ {b="#sender1", num_steps=1, measure=0},
                                              {b="#receiver1", num_steps=1, measure=0} } } }
   },
}
{% endhighlight %}

Thanks to these, we specify which modules will be loaded, which blocks will be created, their configuration and the connections between them (through iblocks).
Further informations about the USC files can be found in [USC documentation](/Documentation/usc_explained).

### Create launch script (optional)

{% highlight bash %}
~/workspace/cpp_transfer$ vim run.sh
#!/bin/bash
exec $UBX_ROOT/tools/ubx_launch -webif 8888 -c cpp_transfer.usc
{% endhighlight %}

### Launch the application!

Now, start ubx!

{% highlight bash %}
~/workspace/cpp_transfer$ ./run.sh
LuaJIT 2.0.2 -- Copyright (C) 2005-2013 Mike Pall. http://luajit.org/
Environment setup...
    UBX_ROOT: /home/jphilips/workspace/microblx
    UBX_MODULES: /home/jphilips/workspace/install/lib/microblx
importing 6 modules... 
    /home/jphilips/workspace/microblx/std_types/stdtypes/stdtypes.so
    /home/jphilips/workspace/microblx/std_blocks/ptrig/ptrig.so
    /home/jphilips/workspace/microblx/std_blocks/lfds_buffers/lfds_cyclic.so
    /home/jphilips/workspace/microblx/std_blocks/hexdump/hexdump.so
    /home/jphilips/workspace/install/lib/microblx/blocks/cpp_sender.so
    /home/jphilips/workspace/install/lib/microblx/blocks/cpp_receiver.so
importing modules completed
instantiating 4 blocks... 
    ptrig1 [std_triggers/ptrig]
    fifo1 [lfds_buffers/cyclic]
    cpp_sender1 [cpp_sender]
    cpp_receiver1 [cpp_receiver]
instantiating blocks completed
launching block diagram system in node node-20140414_111110
    preprocessing configs
    resolved block #cpp_sender1
    resolved block #cpp_receiver1
configuring 2 blocks... 
    fifo1 with {buffer_len=1,type_name="struct cpp_data"}
    ptrig1 with {trig_blocks={ 
                   {b=cpp_sender1 (type=cblock, state=preinit, prototype=cpp_sender),num_steps=1,measure=0},
                   {b=cpp_receiver1 (type=cblock, state=preinit, prototype=cpp_receiver),num_steps=1,measure=0} }, 
                 period={usec=0,sec=1} })
ptrig_handle_config: ptrig1 config: period=1s:0us, policy=SCHED_OTHER, prio=0, stacksize=0 (0=default size)
configuring blocks completed
creating 2 connections... 
    cpp_sender1.output -> fifo1 (iblock)
    fifo1 (iblock) -> cpp_receiver1.input
creating connections completed
starting up webinterface block (port: 8888)
loaded request_handler()
JIT: ON CMOV SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
> 
{% endhighlight %}

![Pins](runusc.png )
  

- Browse to [http://localhost:8888](http://localhost:8888) to start the blocks...
- Init and start the cpp_receiver1 and cpp_sender1 block
- Init and start the ptrig1 block

If all is well, you should receive following output:
{% highlight bash %}
...
MODEL: image array
UID: image
META MODEL: c array
DATA: test_data
MODEL: image array
UID: image
META MODEL: c array
DATA: test_data
MODEL: image array
UID: image
META MODEL: c array
DATA: test_data
...
{% endhighlight %}

Generate pure C application (from ubx system composition file!)
-----------------------------------
(note: still under development. Steps like checkout of dev branch, manually file copying and CMakeFile editing will be automated later on)

First, checkout dev branch of microblx_cmake package
{% highlight bash %}
git checkout dev
{% endhighlight %}

Then, generate the source file for the application with
{% highlight bash %}
./generate_capp -o cpp_transfer_app -f <path-to-cpp_transfer>/cpp_transfer.usc --webif
{% endhighlight %}

and you will find the source as "cpp_transfer_app.c".

As last step, it is necessary to compile the source, by copying the source in one project and adding the following to your CMakeFiles.txt
{% highlight bash %}
add_executable(cpp_transfer_app src_bin/cpp_transfer_app.c)
target_link_libraries(cpp_transfer_app ${UBX_LIBRARIES})
add_dependencies(cpp_transfer_app gen_hexarr)
{% endhighlight %}
Of course, it is possible to do the same if you are using a plain Makefile system.

Compile everything and you should obtain an executable "cpp_transfer_app"

By launch it, you obtain
{% highlight bash %}
All modules have been loaded!
All modules have been created!
ptrig_handle_config: ptrig1_1 config: period=0s:0us, policy=SCHED_OTHER, prio=0, stacksize=0 (0=default size)
All blocks have been initialized!
ptrig_start:  
All blocks have been started!
loaded request_handler()
webif block lauched on port 8888
Everything is up and running! hit enter to quit
{% endhighlight %}
and you can navigate, as usual, to the web interface.